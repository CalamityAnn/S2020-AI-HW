/*
  Assignment 3: The Zebra Problem
  Class: AI Principles and Applications
  Group: Cam Skubik-Peplaski and Nicholas Steinmetz
*/

/* ------------------------------------------------------------ */

% Checks STREET setup against base conditions
  % (HouseColor Nationality Candy Drink Pet)
((check STREET)
  % Englishman lives in red house
  (known ( Red Englishman _ _ _ ) STREET)

  % Spaniard owns a dog
  (known ( _ Spaniard _ _ Dog ) STREET)

  % Norwegian lives in the first house on the left
  (eq STREET (( _ Norwegian _ _ _ ) _ _ _ _ ))

  % Green house is immediately left to right of ivory house
  (rightOf ( Green _ _ _ _ ) ( Ivory _ _ _ _ ) STREET)

  % Man who eats Hershey-bars lives next to man with fox
  (adjacent ( _ _ Hersheys _ _ ) ( _ _ _ _ Fox ) STREET)

  % Kit-Kats are eaten in the yellow house
  (known ( Yellow _ KitKats _ _ ) STREET)

  % Norwegian lives next to the blue house
  (adjacent ( _ Norwegian _ _ _ ) ( Blue _ _ _ _ ) STREET)

  % Smarties eater owns snails
  (known ( _ _ Smarties _ Snails ) STREET)

  % Snickers eater drinks orange juice
  (known ( _ _ Snickers OJ _ ) STREET)

  % Ukranian drinks tea
  (known ( _ Ukranian _ Tea _ ) STREET)

  % Japanese eats milky-ways
  (known ( _ Japanese MilkyWays _ _ ) STREET)

  % Kit-kats are eaten in a house next to the house where the horse is kept
  (adjacent ( _ _ KitKats _ _ ) ( _ _ _ _ Horse ) STREET)

  % Coffee is drunk in the green house
  (known ( Green _ _ Coffee _ ) STREET)

  % Milk is drunk in the middle house
  (middle ( _ _ _ Milk _ ) STREET)
)

/*
  Utility predicates from list_pro
*/
% MEMBER
  % the head of a list is an element of that list
((member H ( H|_ )))
  % otherwise, E is an element of the list if it
((member E ( _|T ))
	  % is an element of its tail
	(member E T))

% Checks if MEM is member of KB
((known MEM KB)
  (member MEM KB))

% Checks if X is right of Y -> specifically used for statement number 4 in this assignment
((rightOf X X _) (fail))
((rightOf X Y ( Y X _ _ _ ) ))
((rightOf X Y ( _ Y X _ _ ) ))
((rightOf X Y ( _ _ Y X _ ) ))
((rightOf X Y ( _ _ _ Y X ) ))

% Checks if X and Y are adjacent in list N
((adjacent X Y N)
  (rightOf X Y N))
((adjacent X Y N)
  (rightOf Y X N))

% Checks if X is in the middle of street
((middle X (_ _ X _ _) ))

% Checks if we've already done a query,
% if not, add to knowledgebase
((decide QUALITY WHO WHAT)
  (QUALITY WHO WHAT)(!) )
((decide QUALITY WHO WHAT)
  (addcl ((QUALITY WHO WHAT)) ))


% Solves Zebra Puzzle
/*
  Arguments:
    1.
*/
((solveZebra ) %Add Args here
 

)

% Color <-> Nationality Query
((color WHO WHAT)
  (knownColor WHO WHAT)(!) )
((color WHO WHAT)
  (puzzle P)(member (WHAT WHO _ _ _) P)
  (decide knownColor WHO WHAT))

% Drink <-> Nationality query
((drinks WHO WHAT)
  (knownToDrink WHO WHAT)(!) )
((drinks WHO WHAT)
  (puzzle P)(member (_ WHO _ WHAT _) P)
  (decide knownToDrink WHO WHAT))

% Candy <-> Nationality query
((eats WHO WHAT)
  (knownToEat WHO WHAT)(!) )
((eats WHO WHAT)
  (puzzle P)(member (_ WHO WHAT _ _) P)
  (decide knownToEat WHO WHAT))

% Pet <-> Nationality query
((pet WHO WHAT)
  (knownPet WHO WHAT)(!) )
((pet WHO WHAT)
  (puzzle P)(member (_ WHO _ _ WHAT) P)
  (decide knownPet WHO WHAT))


% Drink <-> House query
((drinks WHERE WHAT)
  (knownDrinkIn WHERE WHAT)(!) )
((drinks WHERE WHAT)
  (puzzle P)(member (WHERE _ _ WHAT _) P)
  (decide knownDrinkIn WHERE WHAT))

% Candy <-> House query
((eats WHERE WHAT)
  (knownEatIn WHERE WHAT)(!) )
((eats WHERE WHAT)
  (puzzle P)(member (WHERE _ WHAT _ _) P)
  (decide knownEatIn WHERE WHAT))

% Pet <-> House query
((pet WHERE WHAT)
  (knownPetIn WHERE WHAT)(!) )
((pet WHERE WHAT)
  (puzzle P)(member (WHERE _ _ _ WHAT) P)
  (decide knownPetIn WHERE WHAT))


% Printing Functions
((printColor X)
	(p "lives in the" X "colored home")
	(pp " "))

((printCandy X)
	(p "eats" X)
	(pp " "))

((printDrink X)
	(p "drinks" X)
	(pp " "))

((printNationality X)
	(p "is" X)
	(pp " "))

((printPet X)
	(p "has the" X)
	(pp " "))